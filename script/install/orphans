#!/usr/bin/env bash
###############################################################################
#                     .__
#   _________________ |  |__ _____    ____   ______
#  /  _ \_  __ \____ \|  |  \\__  \  /    \ /  ___/
# (  <_> )  | \/  |_> >   Y  \/ __ \|   |  \\___ \
#  \____/|__|  |   __/|___|  (____  /___|  /____  >
#              |__|        \/     \/     \/     \/
#
# Orphans
#
# Programs and packages not available through package managers.
#
# Bash Boilerplate: https://github.com/alphabetum/bash-boilerplate
#
# Copyright (c) 2015 William Melody • hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters ‘@’ or
# ‘*’ as an error when performing parameter expansion. An 'unbound variable'
# error message will be written to the standard error, and a non-interactive
# shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# The two approaches that are probably the most appropriate are:
#
# ${parameter:-word}
#   If parameter is unset or null, the expansion of word is substituted.
#   Otherwise, the value of parameter is substituted. In other words, "word"
#   acts as a default value when the value of "$parameter" is blank. If "word"
#   is not present, then the default is blank (essentially an empty string).
#
# ${parameter:?word}
#   If parameter is null or unset, the expansion of word (or a message to that
#   effect if word is not present) is written to the standard error and the
#   shell, if it is not interactive, exits. Otherwise, the value of parameter
#   is substituted.
#
# Examples
# ========
#
# Arrays:
#
#   ${some_array[@]:-}              # blank default value
#   ${some_array[*]:-}              # blank default value
#   ${some_array[0]:-}              # blank default value
#   ${some_array[0]:-default_value} # default value: the string 'default_value'
#
# Positional variables:
#
#   ${1:-alternative} # default value: the string 'alternative'
#   ${2:-}            # blank default value
#
# With an error message:
#
#   ${1:?'error message'}  # exit with 'error message' if variable is unbound
#
# Short form: set -u
set -o nounset

# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
#
# $DEFAULT_IFS and $SAFER_IFS
#
# $DEFAULT_IFS contains the default $IFS value in case it's needed, such as
# when expanding an array and you want to separate elements by spaces.
# $SAFER_IFS contains the preferred settings for the program, and setting it
# separately makes it easier to switch between the two if needed.
#
# NOTE: also printing $DEFAULT_IFS to /dev/null to avoid shellcheck warnings
# about the variable being unused.
DEFAULT_IFS="$IFS"; printf "%s" "$DEFAULT_IFS" > /dev/null
SAFER_IFS="$(printf '\n\t')"
# Then set $IFS
IFS="$SAFER_IFS"

###############################################################################
# Globals
###############################################################################

_VERSION="1.0.0-alpha"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# A simple function for executing a specified command if the `_use_debug`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
_debug() {
  if [[ "${_use_debug:-"0"}" -eq 1 ]]; then
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  "
    "$@"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
  fi
}
# debug()
#
# Print the specified message if the `_use_debug` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
#
# Usage:
#   debug "Debug info. Variable: $0"
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
#
# Usage:
#   die "Error message. Variable: $0"
die() {
  _die echo "$@"
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
raw_options="$*"

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
#
# In this example, `-x` and `-h` are regular short options, while `o` is
# assumed to have an argument and will be split if joined with the string,
# meaning `-oARG` would be split to `-o ARG`.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#)); do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++)); do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*) options+=("${1%%=*}" "${1#*=}");;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *) options+=("$1");;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize command_argv array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
command_argv=("$0")
# Initialize $cmd and $_use_debug, which can continue to be blank depending on
# what the program needs.
cmd=""
_use_debug=0

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      cmd="help"
      ;;
    --version)
      cmd="version"
      ;;
    --debug)
      _use_debug=1
      ;;
    *)
      # The first non-option argument is assumed to be the command name.
      # All subsequent arguments are added to $command_arguments.
      if [[ -n $cmd ]]; then
        command_argv+=("$opt")
      else
        cmd="$opt"
      fi
      ;;
  esac
done

# Set $command_parameters to $command_argv, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
command_parameters=("${command_argv[@]:1}")

_debug printf "\$cmd: %s\n" "$cmd"
_debug printf "\$raw_options (one per line):\n%s\n" "$raw_options"
_debug printf "\$command_argv: %s\n" "${command_argv[*]}"
_debug printf "\$command_parameters: %s\n" "${command_parameters[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_me
#
# Set to the program's basename.
_me=$(basename "$0")

_debug printf "\$_me: %s\n" "$_me"

###############################################################################
# Load Commands
###############################################################################

# Initialize defined_commands array.
defined_commands=()

# _load_commands()
#
# Loads all of the commands sourced in the environment.
#
# Usage:
#   _load_commands
_load_commands() {

  _debug printf "_load_commands(): entering...\n"
  _debug printf "_load_commands() declare -F:\n%s\n" "$(declare -F)"

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local function_list=($(declare -F))

  for c in "${function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local function_name=$(printf "%s" "$c" | awk '{ print $3 }')

    _debug printf "_load_commands() \$function_name: %s\n" "$function_name"

    # Add the function name to the $defined_commands array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility.
    if ! ( [[ "$function_name" =~ ^_(.*)  ]] || \
           [[ "$function_name" == "desc"  ]] || \
           [[ "$function_name" == "debug" ]] || \
           [[ "$function_name" == "die"   ]]
    ); then
      defined_commands+=("$function_name")
    fi
  done

  _debug printf \
    "commands() \$defined_commands:\n%s\n" \
    "${defined_commands[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\n"
  _debug printf "main() \$cmd (upon entering): %s\n" "$cmd"

  # If $cmd is blank, then set to help
  if [[ -z $cmd ]]; then
    cmd="help"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if ( _contains "$cmd" "${defined_commands[*]:-}" ); then
    # Pass all comment arguments to the program except for the first ($0).
    $cmd "${command_parameters[@]:-}"
  else
    _die printf "Unknown command: %s\n" "$cmd"
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[*]}"
_contains() {
  local test_list=(${*:2})
  for _test_element in "${test_list[@]:-}"
  do
    _debug printf "_contains() \$_test_element: %s\n" "$_test_element"
    if [[ "$_test_element" == "$1" ]]; then
      _debug printf "_contains() match: %s\n" "$1"
      return 0
    fi
  done
  return 1
}

# _command_argv_includes()
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
#
# Usage:
#   _command_argv_includes "an_argument"
_command_argv_includes() {
  _contains "$1" "${command_argv[*]}"
}

###############################################################################
# Program Utility Functions
###############################################################################

# _is_installed_with_homebrew()
#
# Determine if a Homebrew formula is installed.
#
# Usage:
#   _is_installed_with_homebrew "libgit2"
_is_installed_with_homebrew() {
  brew list -1 | grep -q "^${1}\$"
}

# _remove()
#
# If a `trash` command is present in the environment, use that to remove the
# provided path, otherwise, use rm -rf
#
# Usage:
#   _remove /path/to/a/file/or/directory/
_remove() {
  if [[ -f "$(which trash)" ]]; then
    trash "$1"
  else
    rm -rf "$1"
  fi
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && _die printf "desc: No command name specified.\n"
  if [[ -n ${2:-} ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
    _debug printf "desc() set with argument: _desc_%s\n" "$1"
  else
    read -d '' "_desc_$1"
    _debug printf "desc() set with pipe: _desc_%s\n" "$1"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local var="_desc_$1"
  if [[ -n ${!var:-} ]]; then
    printf "%s\n" "${!var}"
  else
   printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc version <<EOM
Usage:
  $_me ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is $_VERSION
EOM
version() {
  printf "%s\n" "$_VERSION"
}

# Help ########################################################################

desc help <<EOM
Usage:
  $_me help [<command>]

Description:
  Display help information for $_me or a specified command.
EOM
help() {
  if [[ ${#command_argv[@]} = 1 ]]; then
    cat <<EOM
                    .__
  _________________ |  |__ _____    ____   ______
 /  _ \\_  __ \\____ \\|  |  \\\\__  \\  /    \\ /  ___/
(  <_> )  | \\/  |_> >   Y  \\/ __ \\|   |  \\\\___ \\
 \\____/|__|  |   __/|___|  (____  /___|  /____  >
             |__|        \\/     \\/     \\/     \\/

Programs and packages not available through package managers.

Version: $_VERSION

Usage:
  $_me command [--command-options] [<arguments>]
  $_me -h | --help
  $_me --version

Options:
  -h --help  Display this help information.
  --version  Display version information.

Help:
  $_me help [<command>]

$(commands)
EOM
  else
    _print_desc "$1"
  fi
}

# Command List ################################################################

desc commands <<EOM
Usage:
  $_me commands [--raw]

Options:
  --raw  Display the command list without formatting.

Description:
  Display the list of available commands.
EOM
commands() {
  if _command_argv_includes "--raw"; then
    printf "%s\n" "${defined_commands[@]}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${defined_commands[@]}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""   - Optional. A short description for the command.
# example() { : }   - The command called by the user.
#
#
# desc example <<EOM
#
#   Usage:
#     $_me example
#   Description:
#     Print "Hello, World!"
#
#     For usage formatting conventions see:
#     - http://docopt.org/
#     - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# EOM
# example() {
#   printf "Hello, World!\n"
# }
#
###############################################################################

# Install / Uninstall #########################################################

# ------------------------------------------------------------------------ bish

desc bish <<-EOM
Usage:
  $_me bish

Description:

Bish is a language that compiles to Bash. It's designed to give shell scripting
a more comfortable and modern feel.

https://github.com/tdenniston/bish
EOM
bish() {
  # Don't install if already installed.
  if [[ -f "$HOME/bin/bish" ]]; then
    printf "bish already installed.\n" && exit 0
  fi

  local binary_name="bish"
  local tmp_repo="/tmp/orphans/bish"
  local remote_url="https://github.com/tdenniston/bish.git"

  git clone "$remote_url" "$tmp_repo" &&
    cd "$tmp_repo" &&
    make &&
    cp "$tmp_repo/$binary_name" "$HOME/bin" &&
    cd "/tmp/orphans" &&
    _remove "$tmp_repo"
}

desc bish_uninstall <<-EOM
Usage:
  $_me bish_uninstall

Description:

Uninstall bish
EOM
bish_uninstall() {
  printf ">> Uninstalling bish\n"
  [[ -e "$HOME/bin/bish"    ]] && _remove "$HOME/bin/bish"
  [[ -e "/tmp/orphans/bish" ]] && _remove "/tmp/orphans/bish"

}

# ------------------------------------------------------------------------- exa

desc exa <<-EOM
Usage:
  $_me exa

Description:

exa is a modern replacement for ls. It uses colours for information by
default, helping you distinguish between many types of files, such as whether
you are the owner, or in the owning group. It also has extra features not
present in the original ls, such as viewing the Git status for a directory,
or recursing into directories with a tree view. exa is written in Rust, so
it's small, fast, and portable.

http://bsago.me/exa/

NOTE: included as an orhan because a rust crate doesn't appear to exist for
it yet and, therefore, it needs to be built with cargo.
EOM
exa() {
  # Don't install if exa is already installed.
  if [[ -f "$HOME/bin/exa" ]]; then
    printf "exa already installed.\n" && exit 0
  fi
  # Make sure cmake is installed
  if [[ ! -f "$(which cmake)" ]]; then
    printf "Install cmake dependency.\n" && exit 0
  fi
  # Make sure libgit2 is installed.
  if ! ( _is_installed_with_homebrew "libgit2" ); then
    printf "Install libgit2 dependency.\n" && exit 0
  fi

  printf ">> Installing exa\n"

  local binary_name="exa"
  local tmp_repo=/tmp/orphans/exa
  local remote_url=https://github.com/ogham/exa.git

  git clone "$remote_url" "$tmp_repo" &&
    cd "$tmp_repo" &&
    cargo build &&
    cp "$tmp_repo/target/$binary_name" "$HOME/bin" &&
    cd "/tmp/orphans" &&
    _remove "$tmp_repo"
}

desc exa_uninstall <<-EOM
Usage:
  $_me exa_uninstall

Description:

Uninstall exa
EOM
exa_uninstall() {
  printf ">> Uninstalling exa\n"
  [[ -e "$HOME/bin/exa"    ]] && _remove "$HOME/bin/exa"
  [[ -e "/tmp/orphans/exa" ]] && _remove "/tmp/orphans/exa"

}

# ------------------------------------------------------------------------ iota

desc iota <<-EOM
Usage:
  $_me iota

Description:

Iota is a terminal-based text-editor written in Rust.

https://github.com/gchp/iota

NOTE: included as an orhan because a rust crate doesn't appear to exist for
it yet and, therefore, it needs to be built with cargo.
EOM
iota() {
  # Don't install if already installed.
  if [[ -f "$HOME/bin/iota" ]]; then
    printf "iota already installed.\n" && exit 0
  fi

  printf ">> Installing iota\n"

  local binary_name="iota"
  local tmp_repo=/tmp/orphans/iota
  local remote_url=https://github.com/gchp/iota.git

  git clone "$remote_url" "$tmp_repo" &&
    cd "$tmp_repo" &&
    cargo build &&
    cp "$tmp_repo/target/$binary_name" "$HOME/bin" &&
    cd "/tmp/orphans" &&
    _remove "$tmp_repo"
}

desc iota_uninstall <<-EOM
Usage:
  $_me iota_uninstall

Description:

Uninstall iota
EOM
iota_uninstall() {
  printf ">> Uninstalling iota\n"
  [[ -e "$HOME/bin/iota"    ]] && _remove "$HOME/bin/iota"
  [[ -e "/tmp/orphans/iota" ]] && _remove "/tmp/orphans/iota"
}

# ---------------------------------------------------------------------- meteor

desc meteor <<-EOM
Usage:
  $_me meteor

Description:

Meteor is an ultra-simple environment for building modern web applications.

With Meteor you write apps:

- in pure JavaScript
- that send data over the wire, rather than HTML
- using your choice of popular open-source libraries
- Documentation is available at http://docs.meteor.com/

https://www.meteor.com/
https://github.com/meteor/meteor
https://install.meteor.com/
EOM
meteor() {
  if [[ -f "/usr/local/bin/meteor" ]]; then
    printf "meteor is already installed.\n" && exit 0
  fi
  printf ">> Installing meteor\n"
  curl https://install.meteor.com | /bin/sh
}

desc meteor_uninstall <<-EOM
Usage:
  $_me meteor_uninstall

Description:

Unisntall Meteor
EOM
meteor_uninstall() {
  printf ">> Uninstalling meteor\n"
  [[ -e "$HOME/.meteor/"        ]] && _remove "$HOME/.meteor/"
  [[ -e "/usr/local/bin/meteor" ]] && _remove "/usr/local/bin/meteor"
}

# ------------------------------------------------------------------------- xsv

desc xsv <<-EOM
Usage:
  $_me xsv

Description:

A fast CSV toolkit written in Rust.

xsv is a command line program for indexing, slicing, analyzing, splitting and
joining CSV files.

https://github.com/BurntSushi/xsv

NOTE: included as an orhan because a rust crate doesn't appear to exist for
it yet and, therefore, it needs to be built with cargo.
EOM
xsv() {
  # Don't install if already installed.
  if [[ -f "$HOME/bin/xsv" ]]; then
    printf "xsv already installed.\n" && exit 0
  fi

  printf ">> Installing xsv\n"

  local binary_name="xsv"
  local tmp_repo=/tmp/orphans/xsv
  local remote_url=https://github.com/BurntSushi/xsv.git

  git clone "$remote_url" "$tmp_repo" &&
    cd "$tmp_repo" &&
    cargo build &&
    cp "$tmp_repo/target/$binary_name" "$HOME/bin" &&
    cd "/tmp/orphans" &&
    _remove "$tmp_repo"
}

desc xsv_uninstall <<-EOM
Usage:
  $_me xsv_uninstall

Description:

Uninstall xsv
EOM
xsv_uninstall() {
  printf ">> Uninstalling xsv\n"
  [[ -e "$HOME/bin/xsv"    ]] && _remove "$HOME/bin/xsv"
  [[ -e "/tmp/orphans/xsv" ]] && _remove "/tmp/orphans/xsv"
}

###############################################################################
# Run Program
###############################################################################

# Platform Check
#
# Limit to OS X, which is the primary platform for this configuration at the
# moment.
if [[ ! "$OSTYPE" =~ ^darwin ]]; then
  printf "orphans is only supported on OS X\nSkipping...\n"
  exit 0
fi

# Calling the _main function after everything has been defined.
_main
